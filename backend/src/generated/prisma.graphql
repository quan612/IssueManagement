type AggregateComment {
  count: Int!
}

type AggregateFile {
  count: Int!
}

type AggregateIssue {
  count: Int!
}

type AggregateLog {
  count: Int!
}

type AggregateProject {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Comment {
  id: ID!
  text: String!
  issue: Issue!
  owner: User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CommentConnection {
  pageInfo: PageInfo!
  edges: [CommentEdge]!
  aggregate: AggregateComment!
}

input CommentCreateInput {
  id: ID
  text: String!
  issue: IssueCreateOneWithoutCommentsInput!
  owner: UserCreateOneWithoutCommentInput!
}

input CommentCreateManyWithoutIssueInput {
  create: [CommentCreateWithoutIssueInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateManyWithoutOwnerInput {
  create: [CommentCreateWithoutOwnerInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateWithoutIssueInput {
  id: ID
  text: String!
  owner: UserCreateOneWithoutCommentInput!
}

input CommentCreateWithoutOwnerInput {
  id: ID
  text: String!
  issue: IssueCreateOneWithoutCommentsInput!
}

type CommentEdge {
  node: Comment!
  cursor: String!
}

enum CommentOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CommentPreviousValues {
  id: ID!
  text: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input CommentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
  NOT: [CommentScalarWhereInput!]
}

type CommentSubscriptionPayload {
  mutation: MutationType!
  node: Comment
  updatedFields: [String!]
  previousValues: CommentPreviousValues
}

input CommentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CommentWhereInput
  AND: [CommentSubscriptionWhereInput!]
  OR: [CommentSubscriptionWhereInput!]
  NOT: [CommentSubscriptionWhereInput!]
}

input CommentUpdateInput {
  text: String
  issue: IssueUpdateOneRequiredWithoutCommentsInput
  owner: UserUpdateOneRequiredWithoutCommentInput
}

input CommentUpdateManyDataInput {
  text: String
}

input CommentUpdateManyMutationInput {
  text: String
}

input CommentUpdateManyWithoutIssueInput {
  create: [CommentCreateWithoutIssueInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutIssueInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutIssueInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyWithoutOwnerInput {
  create: [CommentCreateWithoutOwnerInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutOwnerInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutOwnerInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput!
  data: CommentUpdateManyDataInput!
}

input CommentUpdateWithoutIssueDataInput {
  text: String
  owner: UserUpdateOneRequiredWithoutCommentInput
}

input CommentUpdateWithoutOwnerDataInput {
  text: String
  issue: IssueUpdateOneRequiredWithoutCommentsInput
}

input CommentUpdateWithWhereUniqueWithoutIssueInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutIssueDataInput!
}

input CommentUpdateWithWhereUniqueWithoutOwnerInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutOwnerDataInput!
}

input CommentUpsertWithWhereUniqueWithoutIssueInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutIssueDataInput!
  create: CommentCreateWithoutIssueInput!
}

input CommentUpsertWithWhereUniqueWithoutOwnerInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutOwnerDataInput!
  create: CommentCreateWithoutOwnerInput!
}

input CommentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  issue: IssueWhereInput
  owner: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  NOT: [CommentWhereInput!]
}

input CommentWhereUniqueInput {
  id: ID
}

scalar DateTime

type File {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  filename: String!
  mimetype: String!
  encoding: String!
  url: String!
  issue: Issue!
}

type FileConnection {
  pageInfo: PageInfo!
  edges: [FileEdge]!
  aggregate: AggregateFile!
}

input FileCreateInput {
  id: ID
  filename: String!
  mimetype: String!
  encoding: String!
  url: String!
  issue: IssueCreateOneWithoutAttachmentsInput!
}

input FileCreateManyWithoutIssueInput {
  create: [FileCreateWithoutIssueInput!]
  connect: [FileWhereUniqueInput!]
}

input FileCreateWithoutIssueInput {
  id: ID
  filename: String!
  mimetype: String!
  encoding: String!
  url: String!
}

type FileEdge {
  node: File!
  cursor: String!
}

enum FileOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  filename_ASC
  filename_DESC
  mimetype_ASC
  mimetype_DESC
  encoding_ASC
  encoding_DESC
  url_ASC
  url_DESC
}

type FilePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  filename: String!
  mimetype: String!
  encoding: String!
  url: String!
}

input FileScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  filename: String
  filename_not: String
  filename_in: [String!]
  filename_not_in: [String!]
  filename_lt: String
  filename_lte: String
  filename_gt: String
  filename_gte: String
  filename_contains: String
  filename_not_contains: String
  filename_starts_with: String
  filename_not_starts_with: String
  filename_ends_with: String
  filename_not_ends_with: String
  mimetype: String
  mimetype_not: String
  mimetype_in: [String!]
  mimetype_not_in: [String!]
  mimetype_lt: String
  mimetype_lte: String
  mimetype_gt: String
  mimetype_gte: String
  mimetype_contains: String
  mimetype_not_contains: String
  mimetype_starts_with: String
  mimetype_not_starts_with: String
  mimetype_ends_with: String
  mimetype_not_ends_with: String
  encoding: String
  encoding_not: String
  encoding_in: [String!]
  encoding_not_in: [String!]
  encoding_lt: String
  encoding_lte: String
  encoding_gt: String
  encoding_gte: String
  encoding_contains: String
  encoding_not_contains: String
  encoding_starts_with: String
  encoding_not_starts_with: String
  encoding_ends_with: String
  encoding_not_ends_with: String
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  AND: [FileScalarWhereInput!]
  OR: [FileScalarWhereInput!]
  NOT: [FileScalarWhereInput!]
}

type FileSubscriptionPayload {
  mutation: MutationType!
  node: File
  updatedFields: [String!]
  previousValues: FilePreviousValues
}

input FileSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FileWhereInput
  AND: [FileSubscriptionWhereInput!]
  OR: [FileSubscriptionWhereInput!]
  NOT: [FileSubscriptionWhereInput!]
}

input FileUpdateInput {
  filename: String
  mimetype: String
  encoding: String
  url: String
  issue: IssueUpdateOneRequiredWithoutAttachmentsInput
}

input FileUpdateManyDataInput {
  filename: String
  mimetype: String
  encoding: String
  url: String
}

input FileUpdateManyMutationInput {
  filename: String
  mimetype: String
  encoding: String
  url: String
}

input FileUpdateManyWithoutIssueInput {
  create: [FileCreateWithoutIssueInput!]
  delete: [FileWhereUniqueInput!]
  connect: [FileWhereUniqueInput!]
  set: [FileWhereUniqueInput!]
  disconnect: [FileWhereUniqueInput!]
  update: [FileUpdateWithWhereUniqueWithoutIssueInput!]
  upsert: [FileUpsertWithWhereUniqueWithoutIssueInput!]
  deleteMany: [FileScalarWhereInput!]
  updateMany: [FileUpdateManyWithWhereNestedInput!]
}

input FileUpdateManyWithWhereNestedInput {
  where: FileScalarWhereInput!
  data: FileUpdateManyDataInput!
}

input FileUpdateWithoutIssueDataInput {
  filename: String
  mimetype: String
  encoding: String
  url: String
}

input FileUpdateWithWhereUniqueWithoutIssueInput {
  where: FileWhereUniqueInput!
  data: FileUpdateWithoutIssueDataInput!
}

input FileUpsertWithWhereUniqueWithoutIssueInput {
  where: FileWhereUniqueInput!
  update: FileUpdateWithoutIssueDataInput!
  create: FileCreateWithoutIssueInput!
}

input FileWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  filename: String
  filename_not: String
  filename_in: [String!]
  filename_not_in: [String!]
  filename_lt: String
  filename_lte: String
  filename_gt: String
  filename_gte: String
  filename_contains: String
  filename_not_contains: String
  filename_starts_with: String
  filename_not_starts_with: String
  filename_ends_with: String
  filename_not_ends_with: String
  mimetype: String
  mimetype_not: String
  mimetype_in: [String!]
  mimetype_not_in: [String!]
  mimetype_lt: String
  mimetype_lte: String
  mimetype_gt: String
  mimetype_gte: String
  mimetype_contains: String
  mimetype_not_contains: String
  mimetype_starts_with: String
  mimetype_not_starts_with: String
  mimetype_ends_with: String
  mimetype_not_ends_with: String
  encoding: String
  encoding_not: String
  encoding_in: [String!]
  encoding_not_in: [String!]
  encoding_lt: String
  encoding_lte: String
  encoding_gt: String
  encoding_gte: String
  encoding_contains: String
  encoding_not_contains: String
  encoding_starts_with: String
  encoding_not_starts_with: String
  encoding_ends_with: String
  encoding_not_ends_with: String
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  issue: IssueWhereInput
  AND: [FileWhereInput!]
  OR: [FileWhereInput!]
  NOT: [FileWhereInput!]
}

input FileWhereUniqueInput {
  id: ID
  url: String
}

type Issue {
  id: ID!
  title: String!
  description: String
  type: IssueType!
  status: IssueStatus!
  priority: IssuePriority!
  assignee: User
  reporter: User!
  estimate: Int
  timeSpent: Int
  timeRemaining: Int
  listPosition: Float
  createdAt: DateTime!
  updatedAt: DateTime!
  project: Project!
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
  attachments(where: FileWhereInput, orderBy: FileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [File!]
  dueDate: DateTime
}

type IssueConnection {
  pageInfo: PageInfo!
  edges: [IssueEdge]!
  aggregate: AggregateIssue!
}

input IssueCreateInput {
  id: ID
  title: String!
  description: String
  type: IssueType!
  status: IssueStatus!
  priority: IssuePriority!
  assignee: UserCreateOneWithoutAssignedInput
  reporter: UserCreateOneWithoutReporterInput!
  estimate: Int
  timeSpent: Int
  timeRemaining: Int
  listPosition: Float
  project: ProjectCreateOneWithoutIssuesInput!
  comments: CommentCreateManyWithoutIssueInput
  attachments: FileCreateManyWithoutIssueInput
  dueDate: DateTime
}

input IssueCreateManyWithoutAssigneeInput {
  create: [IssueCreateWithoutAssigneeInput!]
  connect: [IssueWhereUniqueInput!]
}

input IssueCreateManyWithoutProjectInput {
  create: [IssueCreateWithoutProjectInput!]
  connect: [IssueWhereUniqueInput!]
}

input IssueCreateManyWithoutReporterInput {
  create: [IssueCreateWithoutReporterInput!]
  connect: [IssueWhereUniqueInput!]
}

input IssueCreateOneInput {
  create: IssueCreateInput
  connect: IssueWhereUniqueInput
}

input IssueCreateOneWithoutAttachmentsInput {
  create: IssueCreateWithoutAttachmentsInput
  connect: IssueWhereUniqueInput
}

input IssueCreateOneWithoutCommentsInput {
  create: IssueCreateWithoutCommentsInput
  connect: IssueWhereUniqueInput
}

input IssueCreateWithoutAssigneeInput {
  id: ID
  title: String!
  description: String
  type: IssueType!
  status: IssueStatus!
  priority: IssuePriority!
  reporter: UserCreateOneWithoutReporterInput!
  estimate: Int
  timeSpent: Int
  timeRemaining: Int
  listPosition: Float
  project: ProjectCreateOneWithoutIssuesInput!
  comments: CommentCreateManyWithoutIssueInput
  attachments: FileCreateManyWithoutIssueInput
  dueDate: DateTime
}

input IssueCreateWithoutAttachmentsInput {
  id: ID
  title: String!
  description: String
  type: IssueType!
  status: IssueStatus!
  priority: IssuePriority!
  assignee: UserCreateOneWithoutAssignedInput
  reporter: UserCreateOneWithoutReporterInput!
  estimate: Int
  timeSpent: Int
  timeRemaining: Int
  listPosition: Float
  project: ProjectCreateOneWithoutIssuesInput!
  comments: CommentCreateManyWithoutIssueInput
  dueDate: DateTime
}

input IssueCreateWithoutCommentsInput {
  id: ID
  title: String!
  description: String
  type: IssueType!
  status: IssueStatus!
  priority: IssuePriority!
  assignee: UserCreateOneWithoutAssignedInput
  reporter: UserCreateOneWithoutReporterInput!
  estimate: Int
  timeSpent: Int
  timeRemaining: Int
  listPosition: Float
  project: ProjectCreateOneWithoutIssuesInput!
  attachments: FileCreateManyWithoutIssueInput
  dueDate: DateTime
}

input IssueCreateWithoutProjectInput {
  id: ID
  title: String!
  description: String
  type: IssueType!
  status: IssueStatus!
  priority: IssuePriority!
  assignee: UserCreateOneWithoutAssignedInput
  reporter: UserCreateOneWithoutReporterInput!
  estimate: Int
  timeSpent: Int
  timeRemaining: Int
  listPosition: Float
  comments: CommentCreateManyWithoutIssueInput
  attachments: FileCreateManyWithoutIssueInput
  dueDate: DateTime
}

input IssueCreateWithoutReporterInput {
  id: ID
  title: String!
  description: String
  type: IssueType!
  status: IssueStatus!
  priority: IssuePriority!
  assignee: UserCreateOneWithoutAssignedInput
  estimate: Int
  timeSpent: Int
  timeRemaining: Int
  listPosition: Float
  project: ProjectCreateOneWithoutIssuesInput!
  comments: CommentCreateManyWithoutIssueInput
  attachments: FileCreateManyWithoutIssueInput
  dueDate: DateTime
}

type IssueEdge {
  node: Issue!
  cursor: String!
}

enum IssueOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  description_ASC
  description_DESC
  type_ASC
  type_DESC
  status_ASC
  status_DESC
  priority_ASC
  priority_DESC
  estimate_ASC
  estimate_DESC
  timeSpent_ASC
  timeSpent_DESC
  timeRemaining_ASC
  timeRemaining_DESC
  listPosition_ASC
  listPosition_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  dueDate_ASC
  dueDate_DESC
}

type IssuePreviousValues {
  id: ID!
  title: String!
  description: String
  type: IssueType!
  status: IssueStatus!
  priority: IssuePriority!
  estimate: Int
  timeSpent: Int
  timeRemaining: Int
  listPosition: Float
  createdAt: DateTime!
  updatedAt: DateTime!
  dueDate: DateTime
}

enum IssuePriority {
  High
  Medium
  Low
}

input IssueScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  type: IssueType
  type_not: IssueType
  type_in: [IssueType!]
  type_not_in: [IssueType!]
  status: IssueStatus
  status_not: IssueStatus
  status_in: [IssueStatus!]
  status_not_in: [IssueStatus!]
  priority: IssuePriority
  priority_not: IssuePriority
  priority_in: [IssuePriority!]
  priority_not_in: [IssuePriority!]
  estimate: Int
  estimate_not: Int
  estimate_in: [Int!]
  estimate_not_in: [Int!]
  estimate_lt: Int
  estimate_lte: Int
  estimate_gt: Int
  estimate_gte: Int
  timeSpent: Int
  timeSpent_not: Int
  timeSpent_in: [Int!]
  timeSpent_not_in: [Int!]
  timeSpent_lt: Int
  timeSpent_lte: Int
  timeSpent_gt: Int
  timeSpent_gte: Int
  timeRemaining: Int
  timeRemaining_not: Int
  timeRemaining_in: [Int!]
  timeRemaining_not_in: [Int!]
  timeRemaining_lt: Int
  timeRemaining_lte: Int
  timeRemaining_gt: Int
  timeRemaining_gte: Int
  listPosition: Float
  listPosition_not: Float
  listPosition_in: [Float!]
  listPosition_not_in: [Float!]
  listPosition_lt: Float
  listPosition_lte: Float
  listPosition_gt: Float
  listPosition_gte: Float
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  dueDate: DateTime
  dueDate_not: DateTime
  dueDate_in: [DateTime!]
  dueDate_not_in: [DateTime!]
  dueDate_lt: DateTime
  dueDate_lte: DateTime
  dueDate_gt: DateTime
  dueDate_gte: DateTime
  AND: [IssueScalarWhereInput!]
  OR: [IssueScalarWhereInput!]
  NOT: [IssueScalarWhereInput!]
}

enum IssueStatus {
  Backlog
  Open
  InProgress
  Done
}

type IssueSubscriptionPayload {
  mutation: MutationType!
  node: Issue
  updatedFields: [String!]
  previousValues: IssuePreviousValues
}

input IssueSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: IssueWhereInput
  AND: [IssueSubscriptionWhereInput!]
  OR: [IssueSubscriptionWhereInput!]
  NOT: [IssueSubscriptionWhereInput!]
}

enum IssueType {
  Task
  Bug
  Request
}

input IssueUpdateDataInput {
  title: String
  description: String
  type: IssueType
  status: IssueStatus
  priority: IssuePriority
  assignee: UserUpdateOneWithoutAssignedInput
  reporter: UserUpdateOneRequiredWithoutReporterInput
  estimate: Int
  timeSpent: Int
  timeRemaining: Int
  listPosition: Float
  project: ProjectUpdateOneRequiredWithoutIssuesInput
  comments: CommentUpdateManyWithoutIssueInput
  attachments: FileUpdateManyWithoutIssueInput
  dueDate: DateTime
}

input IssueUpdateInput {
  title: String
  description: String
  type: IssueType
  status: IssueStatus
  priority: IssuePriority
  assignee: UserUpdateOneWithoutAssignedInput
  reporter: UserUpdateOneRequiredWithoutReporterInput
  estimate: Int
  timeSpent: Int
  timeRemaining: Int
  listPosition: Float
  project: ProjectUpdateOneRequiredWithoutIssuesInput
  comments: CommentUpdateManyWithoutIssueInput
  attachments: FileUpdateManyWithoutIssueInput
  dueDate: DateTime
}

input IssueUpdateManyDataInput {
  title: String
  description: String
  type: IssueType
  status: IssueStatus
  priority: IssuePriority
  estimate: Int
  timeSpent: Int
  timeRemaining: Int
  listPosition: Float
  dueDate: DateTime
}

input IssueUpdateManyMutationInput {
  title: String
  description: String
  type: IssueType
  status: IssueStatus
  priority: IssuePriority
  estimate: Int
  timeSpent: Int
  timeRemaining: Int
  listPosition: Float
  dueDate: DateTime
}

input IssueUpdateManyWithoutAssigneeInput {
  create: [IssueCreateWithoutAssigneeInput!]
  delete: [IssueWhereUniqueInput!]
  connect: [IssueWhereUniqueInput!]
  set: [IssueWhereUniqueInput!]
  disconnect: [IssueWhereUniqueInput!]
  update: [IssueUpdateWithWhereUniqueWithoutAssigneeInput!]
  upsert: [IssueUpsertWithWhereUniqueWithoutAssigneeInput!]
  deleteMany: [IssueScalarWhereInput!]
  updateMany: [IssueUpdateManyWithWhereNestedInput!]
}

input IssueUpdateManyWithoutProjectInput {
  create: [IssueCreateWithoutProjectInput!]
  delete: [IssueWhereUniqueInput!]
  connect: [IssueWhereUniqueInput!]
  set: [IssueWhereUniqueInput!]
  disconnect: [IssueWhereUniqueInput!]
  update: [IssueUpdateWithWhereUniqueWithoutProjectInput!]
  upsert: [IssueUpsertWithWhereUniqueWithoutProjectInput!]
  deleteMany: [IssueScalarWhereInput!]
  updateMany: [IssueUpdateManyWithWhereNestedInput!]
}

input IssueUpdateManyWithoutReporterInput {
  create: [IssueCreateWithoutReporterInput!]
  delete: [IssueWhereUniqueInput!]
  connect: [IssueWhereUniqueInput!]
  set: [IssueWhereUniqueInput!]
  disconnect: [IssueWhereUniqueInput!]
  update: [IssueUpdateWithWhereUniqueWithoutReporterInput!]
  upsert: [IssueUpsertWithWhereUniqueWithoutReporterInput!]
  deleteMany: [IssueScalarWhereInput!]
  updateMany: [IssueUpdateManyWithWhereNestedInput!]
}

input IssueUpdateManyWithWhereNestedInput {
  where: IssueScalarWhereInput!
  data: IssueUpdateManyDataInput!
}

input IssueUpdateOneInput {
  create: IssueCreateInput
  update: IssueUpdateDataInput
  upsert: IssueUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: IssueWhereUniqueInput
}

input IssueUpdateOneRequiredWithoutAttachmentsInput {
  create: IssueCreateWithoutAttachmentsInput
  update: IssueUpdateWithoutAttachmentsDataInput
  upsert: IssueUpsertWithoutAttachmentsInput
  connect: IssueWhereUniqueInput
}

input IssueUpdateOneRequiredWithoutCommentsInput {
  create: IssueCreateWithoutCommentsInput
  update: IssueUpdateWithoutCommentsDataInput
  upsert: IssueUpsertWithoutCommentsInput
  connect: IssueWhereUniqueInput
}

input IssueUpdateWithoutAssigneeDataInput {
  title: String
  description: String
  type: IssueType
  status: IssueStatus
  priority: IssuePriority
  reporter: UserUpdateOneRequiredWithoutReporterInput
  estimate: Int
  timeSpent: Int
  timeRemaining: Int
  listPosition: Float
  project: ProjectUpdateOneRequiredWithoutIssuesInput
  comments: CommentUpdateManyWithoutIssueInput
  attachments: FileUpdateManyWithoutIssueInput
  dueDate: DateTime
}

input IssueUpdateWithoutAttachmentsDataInput {
  title: String
  description: String
  type: IssueType
  status: IssueStatus
  priority: IssuePriority
  assignee: UserUpdateOneWithoutAssignedInput
  reporter: UserUpdateOneRequiredWithoutReporterInput
  estimate: Int
  timeSpent: Int
  timeRemaining: Int
  listPosition: Float
  project: ProjectUpdateOneRequiredWithoutIssuesInput
  comments: CommentUpdateManyWithoutIssueInput
  dueDate: DateTime
}

input IssueUpdateWithoutCommentsDataInput {
  title: String
  description: String
  type: IssueType
  status: IssueStatus
  priority: IssuePriority
  assignee: UserUpdateOneWithoutAssignedInput
  reporter: UserUpdateOneRequiredWithoutReporterInput
  estimate: Int
  timeSpent: Int
  timeRemaining: Int
  listPosition: Float
  project: ProjectUpdateOneRequiredWithoutIssuesInput
  attachments: FileUpdateManyWithoutIssueInput
  dueDate: DateTime
}

input IssueUpdateWithoutProjectDataInput {
  title: String
  description: String
  type: IssueType
  status: IssueStatus
  priority: IssuePriority
  assignee: UserUpdateOneWithoutAssignedInput
  reporter: UserUpdateOneRequiredWithoutReporterInput
  estimate: Int
  timeSpent: Int
  timeRemaining: Int
  listPosition: Float
  comments: CommentUpdateManyWithoutIssueInput
  attachments: FileUpdateManyWithoutIssueInput
  dueDate: DateTime
}

input IssueUpdateWithoutReporterDataInput {
  title: String
  description: String
  type: IssueType
  status: IssueStatus
  priority: IssuePriority
  assignee: UserUpdateOneWithoutAssignedInput
  estimate: Int
  timeSpent: Int
  timeRemaining: Int
  listPosition: Float
  project: ProjectUpdateOneRequiredWithoutIssuesInput
  comments: CommentUpdateManyWithoutIssueInput
  attachments: FileUpdateManyWithoutIssueInput
  dueDate: DateTime
}

input IssueUpdateWithWhereUniqueWithoutAssigneeInput {
  where: IssueWhereUniqueInput!
  data: IssueUpdateWithoutAssigneeDataInput!
}

input IssueUpdateWithWhereUniqueWithoutProjectInput {
  where: IssueWhereUniqueInput!
  data: IssueUpdateWithoutProjectDataInput!
}

input IssueUpdateWithWhereUniqueWithoutReporterInput {
  where: IssueWhereUniqueInput!
  data: IssueUpdateWithoutReporterDataInput!
}

input IssueUpsertNestedInput {
  update: IssueUpdateDataInput!
  create: IssueCreateInput!
}

input IssueUpsertWithoutAttachmentsInput {
  update: IssueUpdateWithoutAttachmentsDataInput!
  create: IssueCreateWithoutAttachmentsInput!
}

input IssueUpsertWithoutCommentsInput {
  update: IssueUpdateWithoutCommentsDataInput!
  create: IssueCreateWithoutCommentsInput!
}

input IssueUpsertWithWhereUniqueWithoutAssigneeInput {
  where: IssueWhereUniqueInput!
  update: IssueUpdateWithoutAssigneeDataInput!
  create: IssueCreateWithoutAssigneeInput!
}

input IssueUpsertWithWhereUniqueWithoutProjectInput {
  where: IssueWhereUniqueInput!
  update: IssueUpdateWithoutProjectDataInput!
  create: IssueCreateWithoutProjectInput!
}

input IssueUpsertWithWhereUniqueWithoutReporterInput {
  where: IssueWhereUniqueInput!
  update: IssueUpdateWithoutReporterDataInput!
  create: IssueCreateWithoutReporterInput!
}

input IssueWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  type: IssueType
  type_not: IssueType
  type_in: [IssueType!]
  type_not_in: [IssueType!]
  status: IssueStatus
  status_not: IssueStatus
  status_in: [IssueStatus!]
  status_not_in: [IssueStatus!]
  priority: IssuePriority
  priority_not: IssuePriority
  priority_in: [IssuePriority!]
  priority_not_in: [IssuePriority!]
  assignee: UserWhereInput
  reporter: UserWhereInput
  estimate: Int
  estimate_not: Int
  estimate_in: [Int!]
  estimate_not_in: [Int!]
  estimate_lt: Int
  estimate_lte: Int
  estimate_gt: Int
  estimate_gte: Int
  timeSpent: Int
  timeSpent_not: Int
  timeSpent_in: [Int!]
  timeSpent_not_in: [Int!]
  timeSpent_lt: Int
  timeSpent_lte: Int
  timeSpent_gt: Int
  timeSpent_gte: Int
  timeRemaining: Int
  timeRemaining_not: Int
  timeRemaining_in: [Int!]
  timeRemaining_not_in: [Int!]
  timeRemaining_lt: Int
  timeRemaining_lte: Int
  timeRemaining_gt: Int
  timeRemaining_gte: Int
  listPosition: Float
  listPosition_not: Float
  listPosition_in: [Float!]
  listPosition_not_in: [Float!]
  listPosition_lt: Float
  listPosition_lte: Float
  listPosition_gt: Float
  listPosition_gte: Float
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  project: ProjectWhereInput
  comments_every: CommentWhereInput
  comments_some: CommentWhereInput
  comments_none: CommentWhereInput
  attachments_every: FileWhereInput
  attachments_some: FileWhereInput
  attachments_none: FileWhereInput
  dueDate: DateTime
  dueDate_not: DateTime
  dueDate_in: [DateTime!]
  dueDate_not_in: [DateTime!]
  dueDate_lt: DateTime
  dueDate_lte: DateTime
  dueDate_gt: DateTime
  dueDate_gte: DateTime
  AND: [IssueWhereInput!]
  OR: [IssueWhereInput!]
  NOT: [IssueWhereInput!]
}

input IssueWhereUniqueInput {
  id: ID
}

type Log {
  id: ID!
  type: LogType!
  created: DateTime!
  user: User
  issue: Issue
  prevAssignee: User
  newAssignee: User
  previousValue: String
  newValue: String
}

type LogConnection {
  pageInfo: PageInfo!
  edges: [LogEdge]!
  aggregate: AggregateLog!
}

input LogCreateInput {
  id: ID
  type: LogType!
  user: UserCreateOneInput
  issue: IssueCreateOneInput
  prevAssignee: UserCreateOneInput
  newAssignee: UserCreateOneInput
  previousValue: String
  newValue: String
}

type LogEdge {
  node: Log!
  cursor: String!
}

enum LogOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  created_ASC
  created_DESC
  previousValue_ASC
  previousValue_DESC
  newValue_ASC
  newValue_DESC
}

type LogPreviousValues {
  id: ID!
  type: LogType!
  created: DateTime!
  previousValue: String
  newValue: String
}

type LogSubscriptionPayload {
  mutation: MutationType!
  node: Log
  updatedFields: [String!]
  previousValues: LogPreviousValues
}

input LogSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LogWhereInput
  AND: [LogSubscriptionWhereInput!]
  OR: [LogSubscriptionWhereInput!]
  NOT: [LogSubscriptionWhereInput!]
}

enum LogType {
  Open
  Assignee
  Status
  Type
  Priority
  Comment
  Estimate
}

input LogUpdateInput {
  type: LogType
  user: UserUpdateOneInput
  issue: IssueUpdateOneInput
  prevAssignee: UserUpdateOneInput
  newAssignee: UserUpdateOneInput
  previousValue: String
  newValue: String
}

input LogUpdateManyMutationInput {
  type: LogType
  previousValue: String
  newValue: String
}

input LogWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: LogType
  type_not: LogType
  type_in: [LogType!]
  type_not_in: [LogType!]
  created: DateTime
  created_not: DateTime
  created_in: [DateTime!]
  created_not_in: [DateTime!]
  created_lt: DateTime
  created_lte: DateTime
  created_gt: DateTime
  created_gte: DateTime
  user: UserWhereInput
  issue: IssueWhereInput
  prevAssignee: UserWhereInput
  newAssignee: UserWhereInput
  previousValue: String
  previousValue_not: String
  previousValue_in: [String!]
  previousValue_not_in: [String!]
  previousValue_lt: String
  previousValue_lte: String
  previousValue_gt: String
  previousValue_gte: String
  previousValue_contains: String
  previousValue_not_contains: String
  previousValue_starts_with: String
  previousValue_not_starts_with: String
  previousValue_ends_with: String
  previousValue_not_ends_with: String
  newValue: String
  newValue_not: String
  newValue_in: [String!]
  newValue_not_in: [String!]
  newValue_lt: String
  newValue_lte: String
  newValue_gt: String
  newValue_gte: String
  newValue_contains: String
  newValue_not_contains: String
  newValue_starts_with: String
  newValue_not_starts_with: String
  newValue_ends_with: String
  newValue_not_ends_with: String
  AND: [LogWhereInput!]
  OR: [LogWhereInput!]
  NOT: [LogWhereInput!]
}

input LogWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createComment(data: CommentCreateInput!): Comment!
  updateComment(data: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment
  updateManyComments(data: CommentUpdateManyMutationInput!, where: CommentWhereInput): BatchPayload!
  upsertComment(where: CommentWhereUniqueInput!, create: CommentCreateInput!, update: CommentUpdateInput!): Comment!
  deleteComment(where: CommentWhereUniqueInput!): Comment
  deleteManyComments(where: CommentWhereInput): BatchPayload!
  createFile(data: FileCreateInput!): File!
  updateFile(data: FileUpdateInput!, where: FileWhereUniqueInput!): File
  updateManyFiles(data: FileUpdateManyMutationInput!, where: FileWhereInput): BatchPayload!
  upsertFile(where: FileWhereUniqueInput!, create: FileCreateInput!, update: FileUpdateInput!): File!
  deleteFile(where: FileWhereUniqueInput!): File
  deleteManyFiles(where: FileWhereInput): BatchPayload!
  createIssue(data: IssueCreateInput!): Issue!
  updateIssue(data: IssueUpdateInput!, where: IssueWhereUniqueInput!): Issue
  updateManyIssues(data: IssueUpdateManyMutationInput!, where: IssueWhereInput): BatchPayload!
  upsertIssue(where: IssueWhereUniqueInput!, create: IssueCreateInput!, update: IssueUpdateInput!): Issue!
  deleteIssue(where: IssueWhereUniqueInput!): Issue
  deleteManyIssues(where: IssueWhereInput): BatchPayload!
  createLog(data: LogCreateInput!): Log!
  updateLog(data: LogUpdateInput!, where: LogWhereUniqueInput!): Log
  updateManyLogs(data: LogUpdateManyMutationInput!, where: LogWhereInput): BatchPayload!
  upsertLog(where: LogWhereUniqueInput!, create: LogCreateInput!, update: LogUpdateInput!): Log!
  deleteLog(where: LogWhereUniqueInput!): Log
  deleteManyLogs(where: LogWhereInput): BatchPayload!
  createProject(data: ProjectCreateInput!): Project!
  updateProject(data: ProjectUpdateInput!, where: ProjectWhereUniqueInput!): Project
  updateManyProjects(data: ProjectUpdateManyMutationInput!, where: ProjectWhereInput): BatchPayload!
  upsertProject(where: ProjectWhereUniqueInput!, create: ProjectCreateInput!, update: ProjectUpdateInput!): Project!
  deleteProject(where: ProjectWhereUniqueInput!): Project
  deleteManyProjects(where: ProjectWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

enum Permission {
  ADMIN
  PRODUCTOWNER
  USER
}

type Project {
  id: ID!
  name: String!
  key: String!
  issues(where: IssueWhereInput, orderBy: IssueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Issue!]
}

type ProjectConnection {
  pageInfo: PageInfo!
  edges: [ProjectEdge]!
  aggregate: AggregateProject!
}

input ProjectCreateInput {
  id: ID
  name: String!
  key: String!
  issues: IssueCreateManyWithoutProjectInput
}

input ProjectCreateOneWithoutIssuesInput {
  create: ProjectCreateWithoutIssuesInput
  connect: ProjectWhereUniqueInput
}

input ProjectCreateWithoutIssuesInput {
  id: ID
  name: String!
  key: String!
}

type ProjectEdge {
  node: Project!
  cursor: String!
}

enum ProjectOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  key_ASC
  key_DESC
}

type ProjectPreviousValues {
  id: ID!
  name: String!
  key: String!
}

type ProjectSubscriptionPayload {
  mutation: MutationType!
  node: Project
  updatedFields: [String!]
  previousValues: ProjectPreviousValues
}

input ProjectSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProjectWhereInput
  AND: [ProjectSubscriptionWhereInput!]
  OR: [ProjectSubscriptionWhereInput!]
  NOT: [ProjectSubscriptionWhereInput!]
}

input ProjectUpdateInput {
  name: String
  key: String
  issues: IssueUpdateManyWithoutProjectInput
}

input ProjectUpdateManyMutationInput {
  name: String
  key: String
}

input ProjectUpdateOneRequiredWithoutIssuesInput {
  create: ProjectCreateWithoutIssuesInput
  update: ProjectUpdateWithoutIssuesDataInput
  upsert: ProjectUpsertWithoutIssuesInput
  connect: ProjectWhereUniqueInput
}

input ProjectUpdateWithoutIssuesDataInput {
  name: String
  key: String
}

input ProjectUpsertWithoutIssuesInput {
  update: ProjectUpdateWithoutIssuesDataInput!
  create: ProjectCreateWithoutIssuesInput!
}

input ProjectWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  key: String
  key_not: String
  key_in: [String!]
  key_not_in: [String!]
  key_lt: String
  key_lte: String
  key_gt: String
  key_gte: String
  key_contains: String
  key_not_contains: String
  key_starts_with: String
  key_not_starts_with: String
  key_ends_with: String
  key_not_ends_with: String
  issues_every: IssueWhereInput
  issues_some: IssueWhereInput
  issues_none: IssueWhereInput
  AND: [ProjectWhereInput!]
  OR: [ProjectWhereInput!]
  NOT: [ProjectWhereInput!]
}

input ProjectWhereUniqueInput {
  id: ID
  key: String
}

type Query {
  comment(where: CommentWhereUniqueInput!): Comment
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment]!
  commentsConnection(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CommentConnection!
  file(where: FileWhereUniqueInput!): File
  files(where: FileWhereInput, orderBy: FileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [File]!
  filesConnection(where: FileWhereInput, orderBy: FileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FileConnection!
  issue(where: IssueWhereUniqueInput!): Issue
  issues(where: IssueWhereInput, orderBy: IssueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Issue]!
  issuesConnection(where: IssueWhereInput, orderBy: IssueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): IssueConnection!
  log(where: LogWhereUniqueInput!): Log
  logs(where: LogWhereInput, orderBy: LogOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Log]!
  logsConnection(where: LogWhereInput, orderBy: LogOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LogConnection!
  project(where: ProjectWhereUniqueInput!): Project
  projects(where: ProjectWhereInput, orderBy: ProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Project]!
  projectsConnection(where: ProjectWhereInput, orderBy: ProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProjectConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Subscription {
  comment(where: CommentSubscriptionWhereInput): CommentSubscriptionPayload
  file(where: FileSubscriptionWhereInput): FileSubscriptionPayload
  issue(where: IssueSubscriptionWhereInput): IssueSubscriptionPayload
  log(where: LogSubscriptionWhereInput): LogSubscriptionPayload
  project(where: ProjectSubscriptionWhereInput): ProjectSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  email: String!
  name: String!
  password: String!
  permissions: [Permission!]!
  assigned(where: IssueWhereInput, orderBy: IssueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Issue!]
  reporter(where: IssueWhereInput, orderBy: IssueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Issue!]
  comment(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
  avatar: String
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  email: String!
  name: String!
  password: String!
  permissions: UserCreatepermissionsInput
  assigned: IssueCreateManyWithoutAssigneeInput
  reporter: IssueCreateManyWithoutReporterInput
  comment: CommentCreateManyWithoutOwnerInput
  avatar: String
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutAssignedInput {
  create: UserCreateWithoutAssignedInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutCommentInput {
  create: UserCreateWithoutCommentInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutReporterInput {
  create: UserCreateWithoutReporterInput
  connect: UserWhereUniqueInput
}

input UserCreatepermissionsInput {
  set: [Permission!]
}

input UserCreateWithoutAssignedInput {
  id: ID
  email: String!
  name: String!
  password: String!
  permissions: UserCreatepermissionsInput
  reporter: IssueCreateManyWithoutReporterInput
  comment: CommentCreateManyWithoutOwnerInput
  avatar: String
}

input UserCreateWithoutCommentInput {
  id: ID
  email: String!
  name: String!
  password: String!
  permissions: UserCreatepermissionsInput
  assigned: IssueCreateManyWithoutAssigneeInput
  reporter: IssueCreateManyWithoutReporterInput
  avatar: String
}

input UserCreateWithoutReporterInput {
  id: ID
  email: String!
  name: String!
  password: String!
  permissions: UserCreatepermissionsInput
  assigned: IssueCreateManyWithoutAssigneeInput
  comment: CommentCreateManyWithoutOwnerInput
  avatar: String
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  name_ASC
  name_DESC
  password_ASC
  password_DESC
  avatar_ASC
  avatar_DESC
}

type UserPreviousValues {
  id: ID!
  email: String!
  name: String!
  password: String!
  permissions: [Permission!]!
  avatar: String
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  email: String
  name: String
  password: String
  permissions: UserUpdatepermissionsInput
  assigned: IssueUpdateManyWithoutAssigneeInput
  reporter: IssueUpdateManyWithoutReporterInput
  comment: CommentUpdateManyWithoutOwnerInput
  avatar: String
}

input UserUpdateInput {
  email: String
  name: String
  password: String
  permissions: UserUpdatepermissionsInput
  assigned: IssueUpdateManyWithoutAssigneeInput
  reporter: IssueUpdateManyWithoutReporterInput
  comment: CommentUpdateManyWithoutOwnerInput
  avatar: String
}

input UserUpdateManyMutationInput {
  email: String
  name: String
  password: String
  permissions: UserUpdatepermissionsInput
  avatar: String
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutCommentInput {
  create: UserCreateWithoutCommentInput
  update: UserUpdateWithoutCommentDataInput
  upsert: UserUpsertWithoutCommentInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutReporterInput {
  create: UserCreateWithoutReporterInput
  update: UserUpdateWithoutReporterDataInput
  upsert: UserUpsertWithoutReporterInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutAssignedInput {
  create: UserCreateWithoutAssignedInput
  update: UserUpdateWithoutAssignedDataInput
  upsert: UserUpsertWithoutAssignedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdatepermissionsInput {
  set: [Permission!]
}

input UserUpdateWithoutAssignedDataInput {
  email: String
  name: String
  password: String
  permissions: UserUpdatepermissionsInput
  reporter: IssueUpdateManyWithoutReporterInput
  comment: CommentUpdateManyWithoutOwnerInput
  avatar: String
}

input UserUpdateWithoutCommentDataInput {
  email: String
  name: String
  password: String
  permissions: UserUpdatepermissionsInput
  assigned: IssueUpdateManyWithoutAssigneeInput
  reporter: IssueUpdateManyWithoutReporterInput
  avatar: String
}

input UserUpdateWithoutReporterDataInput {
  email: String
  name: String
  password: String
  permissions: UserUpdatepermissionsInput
  assigned: IssueUpdateManyWithoutAssigneeInput
  comment: CommentUpdateManyWithoutOwnerInput
  avatar: String
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutAssignedInput {
  update: UserUpdateWithoutAssignedDataInput!
  create: UserCreateWithoutAssignedInput!
}

input UserUpsertWithoutCommentInput {
  update: UserUpdateWithoutCommentDataInput!
  create: UserCreateWithoutCommentInput!
}

input UserUpsertWithoutReporterInput {
  update: UserUpdateWithoutReporterDataInput!
  create: UserCreateWithoutReporterInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  assigned_every: IssueWhereInput
  assigned_some: IssueWhereInput
  assigned_none: IssueWhereInput
  reporter_every: IssueWhereInput
  reporter_some: IssueWhereInput
  reporter_none: IssueWhereInput
  comment_every: CommentWhereInput
  comment_some: CommentWhereInput
  comment_none: CommentWhereInput
  avatar: String
  avatar_not: String
  avatar_in: [String!]
  avatar_not_in: [String!]
  avatar_lt: String
  avatar_lte: String
  avatar_gt: String
  avatar_gte: String
  avatar_contains: String
  avatar_not_contains: String
  avatar_starts_with: String
  avatar_not_starts_with: String
  avatar_ends_with: String
  avatar_not_ends_with: String
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
